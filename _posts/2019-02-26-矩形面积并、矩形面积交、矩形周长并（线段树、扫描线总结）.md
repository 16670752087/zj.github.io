---
title: 矩形面积并、矩形面积交、矩形周长并（线段树、扫描线总结）
categories: ACM
tags:
  - 扫描线
  - 线段树
date: 2019-02-26 00:46:49
---
跟着[这篇博客](https://blog.csdn.net/lwt36/article/details/48908031)复习扫描线+线段树…
# Atlantis
[题目链接](https://vjudge.net/problem/HDU-1542)

很早之前做过的题目重新拿出来复习线段树…扫描线和线段树结合维护矩形面积并。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef double ll;
struct Ranker : vector<ll>
{
	void init() { sort(begin(), end()), resize(unique(begin(), end()) - begin()); }
	int ask(ll x) const { return lower_bound(begin(), end(), x) - begin(); }
};
struct Area
{
	struct Seg
	{
		ll l, r, h;
		int f;
		bool operator<(const Seg &rhs) const { return h < rhs.h; }
	};
	vector<Seg> s;
	vector<ll> sum;
	vector<int> cnt;
	Ranker rk;
	void add(ll l, ll b, ll r, ll t)
	{
		rk.push_back(l);
		rk.push_back(r);
		s.push_back({l, r, b, 1});
		s.push_back({l, r, t, -1});
	}
	void upd(int ql, int qr, int c, int l, int r, int rt = 1)
	{
		if (ql <= l && r <= qr)
			cnt[rt] += c;
		else
		{
			int m = l + r >> 1;
			if (ql <= m)
				upd(ql, qr, c, l, m, rt << 1);
			if (qr > m)
				upd(ql, qr, c, m + 1, r, rt << 1 | 1);
		}
		sum[rt] = cnt[rt] ? rk[r + 1] - rk[l] : l < r ? sum[rt << 1] + sum[rt << 1 | 1] : 0;
	}
	ll ask()
	{
		rk.init();
		sort(s.begin(), s.end());
		sum.assign(rk.size() * 4, 0);
		cnt.assign(rk.size() * 4, 0);
		ll ans = 0;
		for (int i = 0; i + 1 < s.size(); ++i)
		{
			upd(rk.ask(s[i].l), rk.ask(s[i].r) - 1, s[i].f, 0, rk.size() - 1);
			ans += sum[1] * (s[i + 1].h - s[i].h);
		}
		return ans;
	}
};
int main()
{
	for (int kase = 0, n; ~scanf("%d", &n) && n;)
	{
		Area a;
		for (int i = 0; i < n; ++i)
		{
			ll l, r, b, t;
			scanf("%lf%lf%lf%lf", &l, &r, &b, &t);
			a.add(l, r, b, t);
		}
		printf("Test case #%d\nTotal explored area: %.2lf\n\n", ++kase, a.ask());
	}
}
```
# 覆盖的面积
[题目链接](https://vjudge.net/problem/HDU-1255)

求矩形交。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef double ll;
struct Ranker : vector<ll>
{
	void init() { sort(begin(), end()), resize(unique(begin(), end()) - begin()); }
	int ask(ll x) const { return lower_bound(begin(), end(), x) - begin(); }
};
struct Area
{
	struct Seg
	{
		ll l, r, h;
		int f;
		bool operator<(const Seg &rhs) const { return h < rhs.h; }
	};
	vector<Seg> s;
	vector<ll> one, two;
	vector<int> cnt;
	Ranker rk;
	void add(ll l, ll b, ll r, ll t)
	{
		rk.push_back(l);
		rk.push_back(r);
		s.push_back({l, r, b, 1});
		s.push_back({l, r, t, -1});
	}
	void upd(int ql, int qr, int c, int l, int r, int rt = 1)
	{
		if (ql <= l && r <= qr)
			cnt[rt] += c;
		else
		{
			int m = l + r >> 1;
			if (ql <= m)
				upd(ql, qr, c, l, m, rt << 1);
			if (qr > m)
				upd(ql, qr, c, m + 1, r, rt << 1 | 1);
		}
		if (cnt[rt] >= 2)
			two[rt] = one[rt] = rk[r + 1] - rk[l];
		else if (cnt[rt] == 1)
		{
			one[rt] = rk[r + 1] - rk[l];
			if (l == r)
				two[rt] = 0;
			else
				two[rt] = one[rt << 1] + one[rt << 1 | 1];
		}
		else if (l == r)
			one[rt] = two[rt] = 0;
		else
		{
			one[rt] = one[rt << 1] + one[rt << 1 | 1];
			two[rt] = two[rt << 1] + two[rt << 1 | 1];
		}
	}
	ll ask()
	{
		rk.init();
		sort(s.begin(), s.end());
		one.assign(rk.size() * 4, 0);
		two.assign(rk.size() * 4, 0);
		cnt.assign(rk.size() * 4, 0);
		ll ans = 0;
		for (int i = 0; i + 1 < s.size(); ++i)
		{
			upd(rk.ask(s[i].l), rk.ask(s[i].r) - 1, s[i].f, 0, rk.size() - 1);
			ans += two[1] * (s[i + 1].h - s[i].h);
		}
		return ans;
	}
};
int main()
{
	int t, n;
	for (scanf("%d", &t); t--;)
	{
		Area a;
		scanf("%d", &n);
		for (ll l, b, r, t; n--;)
		{
			scanf("%lf%lf%lf%lf", &l, &b, &r, &t);
			a.add(l, b, r, t);
		}
		printf("%.2lf\n", a.ask());
	}
}
```
# Picture
[题目链接](https://vjudge.net/problem/HDU-1828)

求矩形周长并。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e4 + 9;
struct Seg
{
	int l, r, h, d;
	bool operator<(const Seg &rhs) const { return h < rhs.h; }
} s[N];
int n, sum[N << 2], cnt[N << 2], vtl[N << 2], lbd[N << 2], rbd[N << 2];
void upd(int L, int R, int c, int l, int r, int rt = 1)
{
	if (L <= l && r <= R)
		cnt[rt] += c;
	else
	{
		int m = l + r >> 1;
		if (L <= m)
			upd(L, R, c, l, m, rt << 1);
		if (R > m)
			upd(L, R, c, m + 1, r, rt << 1 | 1);
	}
	if (cnt[rt])
	{
		lbd[rt] = rbd[rt] = 1;
		sum[rt] = r + 1 - l;
		vtl[rt] = 2;
	}
	else if (l == r)
		sum[rt] = vtl[rt] = lbd[rt] = rbd[rt] = 0;
	else
	{
		lbd[rt] = lbd[rt << 1];
		rbd[rt] = rbd[rt << 1 | 1];
		sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
		vtl[rt] = vtl[rt << 1] + vtl[rt << 1 | 1];
		if (rbd[rt << 1] && lbd[rt << 1 | 1])
			vtl[rt] -= 2;
	}
}
int main()
{
	while (~scanf("%d", &n))
	{
		for (int i = 0, x1, y1, x2, y2; i < n; ++i)
		{
			scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
			s[i] = {x1, x2, y1, 1};
			s[i + n] = {x1, x2, y2, -1};
		}
		sort(s, s + n * 2);
		int ans = 0, pre = 0;
		for (int i = 0; i < n * 2; ++i)
		{
			upd(s[i].l, s[i].r - 1, s[i].d, -1e4, 1e4);
			ans += vtl[1] * (s[i + 1].h - s[i].h) + abs(sum[1] - pre);
			pre = sum[1];
		}
		printf("%d\n", ans);
	}
}
```
